![[Pasted image 20260108122001.png]]
- the smaple is an elf 32-bit binary 
- it s statically linked 
- no section header is suspicious and suggests obfuscation or packing existing
![[Pasted image 20260108122320.png]]
- I used strings to see if i can get some info from it , mostly it was random and meaningless strings , until a=the end as observed it says this file is packed with UPX !! and also last strings are UPX! .
- So the next step is to unpack this elf with UPX:
```bash
upx -d 981907e3f5ed07062b33b3e992d1f3412a2f3352208e92c1b58ff3c2387d50ae.elf.defanged 
```

#### Rabin2 :
``` bash
rabin2 -I 981907e3f5ed07062b33b3e992d1f3412a2f3352208e92c1b58ff3c2387d50ae.elf.defanged 
arch     mips
cpu      mips1
baddr    0x400000
binsz    202436
bintype  elf
bits     32
canary   false
injprot  true
class    ELF32
flags    0x1007
abi      o32
crypto   false
endian   big
havecode true
laddr    0x0
lang     c
linenum  false
lsyms    false
machine  MIPS R3000
nx       false
os       linux
pic      false
relocs   false
relro    no
rpath    NONE
sanitize false
static   true
stripped true
subsys   linux
va       true

```
#### String analysis :
- A lot of procs
- Connection and http requests 
- a lot of file extensions , types
- Errors strings 
- Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 
- Interrupts 
- File errors and info
- Suspicious watchdog string
### Sections :
 - Suspicious : .ctors / .dtors / .data.rel.ro 
 - This confirms a **typical, unpacked layout**: `.text` is the main chunk (~0x29ef0) and is **RX** (exec+read), while `.rodata` is **R** only, and the stateful areas (`.data`, `.got`, plus `.bss/.sbss`) are **RW**. That matches a normal compiled C malware that keeps config/strings in `.rodata` and runtime state in `.data/.bss`.

Two suspicious structure cues: the binary has **no NX** (so the stack is not protected), and it includes **constructors/destructors** (`.ctors/.dtors`), which can run setup/teardown code outside the obvious main flow—often used to hide initialization logic. Also, `.sbss` and large `.bss` indicate it keeps a fair amount of runtime state in memory, consistent with a bot that tracks sockets, targets, modes, or command parsing. 
# Radare2 : 
## Functions :
This function list is what you’d expect from a **stripped, statically linked MIPS** malware: very few meaningful names, with the entry point at **0x00400260** (`entry0`) and most code grouped into anonymous `fcn.*` blocks. The standout is `fcn.0041c2d8`—it’s **by far the largest** (928 bytes, 34 basic blocks), which usually means it’s doing the “real work” (command parsing, networking loop, or environment checks), while the tiny helper functions (like `fcn.004000b8`, `fcn.0042a034`, `fcn.00429fa0`) are likely wrappers, setup, or small utilities.

Also, seeing `section..text` as a “function” is a radare2 artifact when it can’t confidently split everything into proper functions—common with MIPS + stripped + static binaries. Net: the code is analyzable but you’ll rely on **xrefs to strings** (like the HTTP templates, `/proc` checks, `!shellcmd`, `87.121.84.11`) to label these functions and map behavior.

#### Analysis :
The sample is a **Linux ELF32 MIPS (R3000) big-endian** executable, consistent with **embedded/IoT targeting** rather than desktop Linux. Its header and detector outputs confirm it’s a normal **ET_EXEC** binary with a fixed base around **0x400000** and an entry point at **0x00400260**, so it’s not a shared object and not position-independent.

Structurally it looks **unpacked and straightforward**: standard sections exist (`.text`, `.rodata`, `.data`, `.bss`, `.got`) with expected permissions (code is RX, data is RW, rodata is R). The presence of `.ctors/.dtors` suggests it can run initialization logic outside the obvious main flow, which is a common place for malware to set up state before its core loop.

The build is **weakly hardened** and attacker-friendly: it is **statically linked** and **stripped**, so there are no imports/symbols to help naming, but it will run reliably across minimal systems. At the same time, protections are absent (**no NX, no canary, no RELRO**), matching typical IoT malware toolchains rather than modern defensive builds.

Strings strongly indicate **botnet-style behavior**. There are extensive `/proc` interactions (`/proc/%s/*`, `/proc/self/exe`, `cmdline`, `stat`, `status`) and an explicit anti-analysis message about exiting a honeypot if `/proc` is missing. This points to **environment discovery and honeypot/container checks** before proceeding.

Networking and command control are explicit in the templates: the binary contains full **HTTP request formats** (GET/POST/HEAD) and spoofs a **Windows Chrome User-Agent**, which suggests it tries to blend into typical traffic. The hardcoded IP **87.121.84.11** is a strong **C2 indicator**, and additional knobs like `httpmode=`, `icmp`, `udpplain`, `port`, `srcport`, and `psize` suggest multiple traffic/attack modes beyond simple HTTP.

Execution capability is also present: strings like `/bin/sh`, `"%s 2>&1"`, and command tags such as `!shellcmd`, `!update`, and `!kill` indicate the malware likely supports **remote shell command execution** and control commands from its operator. Writables paths (`/tmp`, `/var`, `/dev/shm`) and download tools (`wget`, `curl`, `tftp`, `ftpget`) suggest **payload fetching / staging** behavior.

Random-looking strings (e.g., `npxXoudifFeEgGaACScs`) are best interpreted as **obfuscation artifacts or internal identifiers**, not meaningful text. The “format-string exploit” idea isn’t supported by these strings alone: what we see are normal formatting patterns for parsing and building paths/requests, and there’s no clear `%n`-style write primitive indicated in the provided excerpts.

Finally, analysis tooling results match the above: the binary being stripped/static leads to **few recovered function names** (`fcns 7`, `imports 0`, `symbols 0`), but the extremely high **xrefs** count indicates logic heavily anchored around strings and formatted parsing. The largest recovered function region is a strong candidate for the **main control/command loop** (networking + parsing + dispatch), with smaller helper blocks around setup and utilities.

#### ELF header analysis :
This header confirms it’s a **valid ELF32** for **MIPS R3000**, **big-endian**, **ET_EXEC** (normal executable), System V ABI. The **entry point is 0x400260**, which matches the fixed-layout MIPS executable style (typical embedded/IoT builds).

Layout-wise it’s small and clean: **3 program headers** (loader view) starting at byte **52**, and **14 section headers** starting near the end of the file (**202,536**), consistent with an unpacked binary. The **e_flags** (`o32, mips1, noreorder` + `pic/cpic`) indicate the MIPS ABI/calling conventions and that the code may use PIC-style conventions even though it’s still an `EXEC` binary.
### Ghidra Analysis :
the import summary of ghidra lines up perfectly with what we already inferred:

- Ghidra recognizes it as **MIPS 32-bit big-endian** (`MIPS:BE:32`) and loads it as an **ELF executable** with **image base 0x400000** (classic fixed-layout IoT style).
    
- It created **14 memory blocks**, matching your section/segment view; the reported **# of bytes (~1.27MB)** is the _loaded memory footprint_ (includes NOBITS like `.bss/.sbss` + alignment), not just the on-disk size.
    
- `# of Instructions: 0` and only `# of Functions: 1` means you’re currently looking at **import-only / pre-analysis state** — nothing is disassembled/labeled yet, which is expected for a **stripped static** binary.
    
- Hashes match your IOC: **MD5 f8584b2b…** and the shown **SHA-256** for tracking/reporting.
    
- `Relocatable: false` / `Prelinked: false` is consistent with **ET_EXEC non-PIE** behavior we saw earlier.
**`fcn.0041c2d8`** decompilation analysis : 
`processEntry` sets up a small stack frame and then calls `FUN_0041c2d8(...)` with what looks like the **real main pointer** (`&DAT_00404dc0`) plus an **init callback** (`&LAB_00400094`). After that it drops into an **infinite loop**, which is typical in decompilation when the function is marked `noreturn` (startup hands control away and never comes back), or for daemon-style code where the runtime never returns cleanly.

So the next “real behavior” target is whatever `DAT_00404dc0` resolves to (the main/dispatcher), plus whatever `LAB_00400094` does (early init / constructors).
From the entry it ' s the first function to be called .
This “heavy” function is almost certainly the **C runtime startup wrapper** (the equivalent of `__libc_start_main` for a static MIPS build), not the malware’s core logic. The pattern matches: it computes `argv + argc`, walks past the **envp NULL terminator**, then iterates **auxv key/value pairs** (type/value, stepping by 2) and copies a few low-numbered auxv entries into a local table before calling setup routines.

After that, it runs early initialization (including a “secure mode” style check via UID/EUID comparisons), initializes globals like the program name (`argv[0]`), clears error-state pointers (looks like `errno`/`h_errno` style storage), and then finally calls the real program entry `(*param_1)(argc, argv, envp)`. So the meaningful malware behavior you care about will be inside the function pointer `param_1` (the “main” equivalent), not in this startup glue.

### Can t go further in analysis :

- The binary is stripped and after decompiling , there was a huuuge number of functions , without labels or symbols because it s stripped , i tried to serach for the suspicious or behavior related strings that we got from strings in ghidra (hoping to find a label , or value ) but everything was just in .data , and found nothing inside functions that can lead me somewhere, the idea of searching in those functions risks falling in rabbit hole  (Not a good idea), and missing the important part (as my experience the more u deep in details and dat inside functions without direction , mostly u re lost and need to start again) . So the idea of analyzing the malware from the decompiled version or even assembly is suicide (hell nah ) , anad this is intended from malware author to make it insane for reverse engineering to analyze the malware . At least we got some info about the mawlare and what it s related too , but the actual payload or behavior is still hard to identify jsut from static analysis . Ofc , dynamic analysis will help us more , and we can analyze the workflow of the program during the execution (Need to learn building Sandboxes in order to do that : )) 

###  Deliverables 
### 2.1 ELF header and load view

Malware_Analysis_Lab2

From the header/tooling results, the sample is a valid **ELF32 MIPS** executable, **big-endian**, targeting **Linux** with **o32 ABI** on **MIPS R3000/MIPS1**, loaded at a fixed base around **0x400000** with an entry point near **0x400260**. It is **ET_EXEC** (not a shared object), **non-PIE** (fixed layout) and **stripped**, which is consistent with embedded/IoT malware meant to run broadly while hiding symbol names.

Hardening is notably weak: **no NX**, **no stack canary**, and **no RELRO** were reported, making the binary look like a “compatibility first” embedded build rather than a defensive production build. The program is also **statically linked** (imports/symbols absent), which improves reliability on minimal systems and simultaneously reduces easy static breadcrumbs.

### 2.2 Sections and structure 

Malware_Analysis_Lab2

The section layout is largely standard and “clean”: `.text` holds executable code with RX permissions, `.rodata` holds readable constants/strings, and writable state lives in `.data`, `.got`, with `.bss/.sbss` as NOBITS memory-only storage. The presence of normal sections and the large amount of readable strings strongly suggest the sample is **not heavily packed**; instead, it looks like straightforward compiled C code with behavior implemented directly in the binary.

Although `.ctors/.dtors` exist, the constructor table you checked contains the classic `0xFFFFFFFF` terminator, so it likely isn’t relying on constructor callbacks to hide early behavior there. Also, the presence of a MIPS-specific debug/ABI section (`.mdebug.abi32`) is consistent with embedded toolchains and can help fingerprint the build style, even if the binary is stripped.

### 2.3 Strings, capabilities, and likely intent 

Malware_Analysis_Lab2

Strings strongly indicate **environment discovery / anti-honeypot logic**: heavy `/proc` usage and an explicit message about exiting when `/proc` is missing. Network behavior is explicit with full **HTTP request templates** (GET/POST/HEAD) and a **spoofed Windows Chrome User-Agent**, plus parameters suggesting multiple traffic/attack modes (HTTP/ICMP/UDP). A hardcoded IP **87.121.84.11** stands out as a high-value **C2 indicator**.

Command-and-control style keywords like `!shellcmd`, `!update`, `!kill`, and `ping/pong` combined with `/bin/sh` and output redirection (`%s 2>&1`) point to **remote command execution** and operator-driven control. The staging paths (`/tmp`, `/dev/shm`, `/var`) and downloader tool strings (`wget`, `curl`, `tftp`, `ftpget`) suggest payload fetching and execution on compromised devices. The mention of **“iranbot.xmrig”** aligns with a **botnet/cryptominer ecosystem**, matching the MIPS IoT targeting and the overall feature set.

# Conclusion :
Based on the strings and build profile, this is best classified as an **IoT botnet-style Linux/MIPS malware** that **self-identifies as “iranbot”** and appears to bundle or deploy a **cryptominer component (xmrig)**. The HTTP templates, `ping/pong` C2-style commands, `!shellcmd/!update/!kill`, and attack-mode knobs (`icmp`, `udpplain`, ports/psize) fit a **Mirai-like bot + DDoS/control framework**, but the most defensible “family” label from your evidence is **IranBot (xmrig botnet variant)** 

